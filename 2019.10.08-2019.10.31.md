## HTTP
### HTTP/1.0 
```
新增：
1. 请求中增加版本号
2. 有了header
3. 增加了http status code

缺点：
每一个请求都需要新建一个TCP连接，而且是串行。
所以就算网速变快了，打开网页的速度还是很慢。
```

### HTTP/1.1
```
HTTP/1.1主要解决及网络性能问题。

1. 可以设置Keepalive来让HTTP重用TCP链接（这样就不用每次请求都需要3次握手），这就是所谓的“长连接”或是“请求响应式的HTTP持久链接”。
（好处有了，还有不完美的地方？-->  不能做到服务端向客户端推送，只能是客户端每 request一次，服务端response一次。websocket解决了该问题。）

2. 支持pipeline网络传输，只要第一个请求发出去了，不必等其回来，就可以发送第二次请求，可以减少整体响应时间。

3. 支持Chunked Responses, 在response的时候，不必说明Content-Length，客户端就不能断开连接，知道收到服务端的EOF标志。这种技术又叫做“服务端Push模型”，或是" 服务端Push式的HTTP持久链接"

4. 还正式加入了一个很重要的头—— HOST， 这样的话，服务器就知道你要请求哪个网站了。因为可以有多个域名解析到同一个IP上，要区分用户是请求的哪个域名，就需要在HTTP的协议中加入域名的信息，而不是被DNS转换过的IP信息。

缺点：
虽然HTTP/1.1可以重用TCP链接，但请求还是串行的，需要保证顺序性。

传输数据是以文本的方式，数据量较大，如果进行压缩，那么在客户端和服务端又会增加压缩和解压的消耗。（HTTP/2来解决这个问题， 二进制传输）
```

### HTTP/2
[HTTP/2协议详解](https://github.com/zqjflash/http2-protocol)

```
HTTP/2主要解决了之前的性能问题。

1. HTTP/2是一个二进制协议，增加了数据传输效率。

2. HTTP/2可以在一个TCP链接中并发请求多个HTTP请求。

3. HTTP/2会压缩头，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的HPACK算法。

4. HTTP/2允许服务端在客户端放cache，又叫服务端push，也就是说，你没有请求的东西，我服务端可以先送给你放在你的本地缓存中。比如，你请求X，我服务端知道X依赖于Y，虽然你没有的请求Y，但我把把Y跟着X的请求一起返回客户端。
```
